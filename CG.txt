# -*- coding: utf-8 -*-
"""
泊位-岸桥集成调度 Dantzig-Wolfe 分解 + 列生成算法 Demo
========================================================
本示例完整实现了用户需求中描述的主问题 (2.4.1) 与子问题 (2.4.2) 的列生成框架，
并尽可能在代码中显式呈现目标函数与约束（115）~（160）所涉及的全部变量。为
了保证可读性，所有关键步骤都使用中文进行详细注释，便于在 PyCharm 2022.1.2
环境下直接阅读与运行。求解器统一使用 Gurobi 12.0.1（gurobipy）。

注意事项与实现假设
------------------
1. 数据文件 Data_ThreeDay_0.xlsx 已放置在仓库根目录，可直接读取。
2. 初始列生成启发式算法基于 HAlgorithm.txt 中给出的贪婪思路：按预计离港时间
   升序排船、按照泊位/岸桥属性与基线分配尽量早地排程，并显式生成 20 个决策
   变量（13 个原始变量 + 7 个线性化变量）。
3. 主问题使用线性松弛的 s_hv（0<=s_hv<=1），约束覆盖 (116)~(119)：
   - (116) 每条船仅选择一个方案；
   - (117) 泊位占用冲突；
   - (118) 泊位-任务层面的占用冲突；
   - (119) 岸桥占用冲突。
4. 子问题按船舶逐个求解，包含 (120)~(160) 的全部变量与核心约束：任务分配、
   时间逻辑、速率上下界、互斥与优先级关系、泊位/岸桥时间占用的线性化表达，
   以及 O_vbb'、Z_vb 等移泊逻辑。目标函数采用加权多目标形式，对应 (120)。
5. 列生成循环：
   - 先用启发式生成初始列，构建限制主问题 (RMP)；
   - 解 RMP 得到影子价格（对偶值），
   - 用对偶值求解每艘船的子问题，计算检验数 (Reduced Cost)，若 <0 则加入新列；
   - 迭代直到所有子问题的检验数 >=0。
6. 结果输出严格遵循需求中的格式：目标值、分量、s_hv、以及详细的船舶/泊位/
   岸桥视角时间表。
"""
import math
import os
import pandas as pd
from collections import defaultdict
from typing import Dict, List, Tuple, Any

# gurobipy 12.0.1 接口
import gurobipy as gp
from gurobipy import GRB


# =============================================================================
# 数据读取与预处理
# =============================================================================

def load_data(file_path: str = None) -> Dict[str, Any]:
    """读取 Excel 数据并构造需求中列出的参数集合。

    旧版代码写死了 Windows 盘符（``D:\``），在 Linux 或其他环境会导致文件
    无法找到并直接报错。现在改为：
    - 如果显式传入 ``file_path``，优先使用该路径；
    - 否则读取脚本同目录下的 ``Data_ThreeDay_0.xlsx``，与仓库结构保持一致。
    """
    if file_path is None:
        root_dir = os.path.dirname(os.path.abspath(__file__))
        file_path = os.path.join(root_dir, "D:\Data_ThreeDay_0.xlsx")

    df = pd.read_excel(file_path, sheet_name="Three Day")

    # 泊位属性配置：泊位 -> 可执行任务集合
    berths = {
        'b1': ['j1'],
        'b2': ['j1'],
        'b3': ['j2', 'j3', 'j5'],
        'b4': ['j2', 'j3', 'j5', 'j6', 'j7'],
        'b5': ['j2', 'j3', 'j5', 'j6', 'j7'],
        'b6': ['j2', 'j3', 'j5', 'j6', 'j7'],
        'b7': ['j2', 'j3', 'j5', 'j6', 'j7'],
        'b8': ['j2', 'j3', 'j4'],
        'b9': ['j2', 'j3', 'j4'],
    }

    # 需要岸桥作业的任务集合、互斥集合
    JQ = ['j2', 'j3']
    JE = ['j1']

    # 任务优先级关系 p_jj'：仅 j3 需在 j2 之后，其余为 0
    # p_jj_prime = {('j2', 'j3'): 1}
    p_jj_prime = {
        ('j1', 'j2'): 0, ('j1', 'j3'): 0, ('j1', 'j4'): 0, ('j1', 'j5'): 0, ('j1', 'j6'): 0, ('j1', 'j7'): 0,
        ('j2', 'j1'): 0, ('j2', 'j3'): 1, ('j2', 'j4'): 0, ('j2', 'j5'): 0, ('j2', 'j6'): 0, ('j2', 'j7'): 0,
        ('j3', 'j1'): 0, ('j3', 'j2'): 0, ('j3', 'j4'): 0, ('j3', 'j5'): 0, ('j3', 'j6'): 0, ('j3', 'j7'): 0,
        ('j4', 'j1'): 0, ('j4', 'j2'): 0, ('j4', 'j3'): 0, ('j4', 'j5'): 0, ('j4', 'j6'): 0, ('j4', 'j7'): 0,
        ('j5', 'j1'): 0, ('j5', 'j2'): 0, ('j5', 'j3'): 0, ('j5', 'j4'): 0, ('j5', 'j6'): 0, ('j5', 'j7'): 0,
        ('j6', 'j1'): 0, ('j6', 'j2'): 0, ('j6', 'j3'): 0, ('j6', 'j4'): 0, ('j6', 'j5'): 0, ('j6', 'j7'): 0,
        ('j7', 'j1'): 0, ('j7', 'j2'): 0, ('j7', 'j3'): 0, ('j7', 'j4'): 0, ('j7', 'j5'): 0, ('j7', 'j6'): 0
    }

    # 岸桥集合
    Q = ['q1', 'q2', 'q3']

    # 移泊时间（小时）
    tc_v = 0.5

    # 基线作业速率与上限
    v_j = {'j1': 100, 'j2': 20, 'j3': 20, 'j4': 70, 'j5': 45, 'j6': 150, 'j7': 100}
    vup_j = {'j1': 150, 'j2': 40, 'j3': 40, 'j4': 160, 'j5': 90, 'j6': 200, 'j7': 150}

    # 大 M 值
    M = 10000

    # 时间参数
    t_ld = 1 / 6  # 10 分钟
    t_s = 8  # 调度开始
    t_l =16  # 截止
    t_xx = int((t_l - t_s) / t_ld)
    T_set = list(range(t_xx + 1))

    # 成本参数
    c_b = 1000
    c_q = 1000
    c_j = 1000
    c_d = 10000
    c_s = 10000

    # 目标权重
    alpha1 = 0.4
    alpha2 = 0.2
    alpha3 = 0.2
    alpha4 = 0.2

    # 船舶集合 V
    V = [f"v{int(row['Vessel No.'])}" for _, row in df.iterrows()]

    # 任务集合
    J_all = ['j1', 'j2', 'j3', 'j4', 'j5', 'j6', 'j7']
    task_mapping = {
        'Refueling': 'j1',
        'Unloading': 'j2',
        'Loading': 'j3',
        'Charging': 'j4',
        'Water-filling': 'j5',
        'Adding ash': 'j6',
        'Adding mud': 'j7'
    }

    # 每艘船需要调度的任务集合 JR_v
    JR_v = {}
    n_vj = {}
    x_vbj_baseline = {}
    y_vqj_baseline = {}
    t_v_d = {}

    for _, row in df.iterrows():
        vessel = f"v{int(row['Vessel No.'])}"
        JR_v[vessel] = []
        t_v_d[vessel] = row['Expected departure time']

        for task_name, task_id in task_mapping.items():
            n_col = f"{task_name}_n_vj"
            x_col = f"{task_name}_x_vbj"
            y_col = f"{task_name}_y_vqj"

            if pd.notna(row[n_col]) and row[n_col] > 0:
                JR_v[vessel].append(task_id)
                n_vj[(vessel, task_id)] = row[n_col]

                if pd.notna(row[x_col]):
                    x_vbj_baseline[(vessel, task_id)] = f"b{int(row[x_col])}"
                if task_id in JQ and pd.notna(row[y_col]):
                    y_vqj_baseline[(vessel, task_id)] = f"q{int(row[y_col])}"

    # 泊位可执行任务集合 B_j
    B_j = {j: [b for b in berths if j in berths[b]] for j in J_all}

    return {
        'df': df,
        'berths': berths,
        'JQ': JQ,
        'JE': JE,
        'p_jj_prime': p_jj_prime,
        'Q': Q,
        'tc_v': tc_v,
        'v_j': v_j,
        'vup_j': vup_j,
        'M': M,
        't_ld': t_ld,
        't_s': t_s,
        't_l': t_l,
        't_xx': t_xx,
        'T_set': T_set,
        'c_b': c_b,
        'c_q': c_q,
        'c_j': c_j,
        'c_d': c_d,
        'c_s': c_s,
        'alpha1': alpha1,
        'alpha2': alpha2,
        'alpha3': alpha3,
        'alpha4': alpha4,
        'V': V,
        'J_all': J_all,
        'JR_v': JR_v,
        'n_vj': n_vj,
        'x_vbj_baseline': x_vbj_baseline,
        'y_vqj_baseline': y_vqj_baseline,
        't_v_d': t_v_d,
        'B_j': B_j,
    }


# =============================================================================
# 初始列生成启发式（基于 HAlgorithm.txt 思路）
# =============================================================================

def generate_initial_columns(data: Dict[str, Any]):
    """按照预计离港时间升序贪婪生成每艘船的一个方案 hv。"""
    V = data['V']
    JR_v = data['JR_v']
    B_j = data['B_j']
    JQ = data['JQ']
    JE = data['JE']
    p_jj_prime = data['p_jj_prime']
    Q = data['Q']
    tc_v = data['tc_v']
    v_j = data['v_j']
    vup_j = data['vup_j']
    t_ld = data['t_ld']
    t_s = data['t_s']
    T_set = data['T_set']
    n_vj = data['n_vj']
    x_vbj_baseline = data['x_vbj_baseline']
    y_vqj_baseline = data['y_vqj_baseline']
    t_v_d = data['t_v_d']

    # 占用表：泊位 -> t -> 是否被占
    berth_busy = defaultdict(lambda: {t: None for t in T_set})
    quay_busy = defaultdict(lambda: {t: None for t in T_set})

    # 结果：Hv[v] = [column_dict]
    Hv = defaultdict(list)

    # 船舶按预计离港时间排序
    V_sorted = sorted(V, key=lambda vv: t_v_d[vv])

    for v in V_sorted:
        tasks = JR_v[v]
        # 按优先级排序：保证 j2 在 j3 之前
        tasks_sorted = sorted(tasks, key=lambda j: (0 if j == 'j2' else 1 if j == 'j3' else 2, j))

        # 存储各决策变量
        X = {}  # X_vbj
        Y = {}  # Y_vqj
        TS = {}
        TE = {}
        TE_v = 0
        S = defaultdict(lambda: math.inf)
        E = defaultdict(lambda: -math.inf)
        SB = defaultdict(int)
        SBJ = defaultdict(int)
        SQJ = defaultdict(int)
        G = {}
        O = defaultdict(int)
        Z = defaultdict(int)
        phi = {}
        gamma = {}
        delay = 0
        alpha_var = defaultdict(int)
        beta_var = defaultdict(int)
        chi_var = defaultdict(int)
        psi_var = defaultdict(int)

        last_berth = None
        last_end = t_s

        for j in tasks_sorted:
            # 选择泊位：优先基线，其次最早可用
            candidate_berths = B_j[j]
            base_b = x_vbj_baseline.get((v, j))
            if base_b in candidate_berths:
                candidate_berths = [base_b] + [b for b in candidate_berths if b != base_b]
            chosen_b = None
            chosen_start = None
            chosen_end = None
            chosen_rate = None
            chosen_quay = None

            # 如果任务需要岸桥，选择岸桥（基线优先）
            candidate_quays = list(Q) if j in JQ else [None]
            base_q = y_vqj_baseline.get((v, j)) if j in JQ else None
            if base_q and base_q in candidate_quays:
                candidate_quays = [base_q] + [q for q in candidate_quays if q != base_q]

            duration_base = n_vj[(v, j)] / v_j[j]

            for b in candidate_berths:
                for q in candidate_quays:
                    # 计算最早可开工时间：考虑上一任务结束、移泊时间、资源占用
                    earliest = last_end
                    if last_berth and last_berth != b:
                        earliest += tc_v

                    for t in T_set:
                        abs_t = t_s + t * t_ld
                        if abs_t < earliest:
                            continue

                        start_time = abs_t
                        end_time = start_time + duration_base

                        # 将时间段映射到离散时间索引，覆盖整个作业窗口
                        start_idx = max(0, int(math.floor((start_time - t_s) / t_ld)))
                        end_idx = min(len(T_set), int(math.ceil((end_time - t_s) / t_ld)))

                        # 检查泊位在整个时间段的独占性（约束 35）
                        berth_conflict = any(
                            berth_busy[b][tau] not in (None, v) for tau in range(start_idx, end_idx)
                        )
                        if berth_conflict:
                            continue

                        # 检查岸桥在整个时间段的独占性（约束 36）
                        if q:
                            quay_conflict = any(
                                quay_busy[q][tau] not in (None, v) for tau in range(start_idx, end_idx)
                            )
                            if quay_conflict:
                                continue

                        # 速率可调，尝试用基线速率
                        rate = v_j[j]
                        chosen_b, chosen_q = b, q
                        chosen_start, chosen_end = start_time, end_time
                        chosen_rate = rate
                        break
                    if chosen_b:
                        break
                if chosen_b:
                    break

            # 若找不到空档，顺延到最晚时间
            if not chosen_b:
                chosen_b = candidate_berths[0]
                chosen_q = candidate_quays[0]
                chosen_rate = v_j[j]
                chosen_start = last_end + (tc_v if last_berth and last_berth != chosen_b else 0)
                chosen_end = chosen_start + duration_base

            # 更新占用表floor
            start_idx = max(0, int(math.floor((chosen_start - t_s) / t_ld)))
            end_idx = min(len(T_set), int(math.ceil((chosen_end - t_s) / t_ld)))
            for t in range(start_idx, end_idx):
                berth_busy[chosen_b][t] = v
                SB[(chosen_b, t)] = 1
                SBJ[(chosen_b, j, t)] = 1
                alpha_var[(chosen_b, t)] = 1
                beta_var[(chosen_b, t)] = 1
                if chosen_q:
                    quay_busy[chosen_q][t] = v
                    SQJ[(chosen_q, j, t)] = 1
                    chi_var[(chosen_q, j, t)] = 1
                    psi_var[(chosen_q, j, t)] = 1

            # 记录变量
            X[(chosen_b, j)] = 1
            if chosen_q:
                Y[(chosen_q, j)] = 1
            TS[j] = chosen_start
            TE[j] = chosen_end
            G[j] = chosen_rate
            Z[chosen_b] = 1
            if last_berth and last_berth != chosen_b:
                O[(last_berth, chosen_b)] = 1

            last_berth = chosen_b
            last_end = chosen_end

        TE_v = max(TE.values()) if TE else 0
        delay = max(0, TE_v - t_v_d[v])

        # 偏离变量 phi/gamma
        for (b, j), val in X.items():
            base = x_vbj_baseline.get((v, j))
            phi[(b, j)] = 0 if base == b else 1
        for (q, j), val in Y.items():
            base = y_vqj_baseline.get((v, j))
            gamma[(q, j)] = 0 if base == q else 1

        column = {
            'X': X,
            'Y': Y,
            'TS': TS,
            'TE': TE,
            'TE_v': TE_v,
            'S': {b: (min([TS[j] for (bb, j) in X if bb == b]) if any(bb == b for (bb, _) in X) else 0) for b in data['berths']},
            'E': {b: (max([TE[j] for (bb, j) in X if bb == b]) if any(bb == b for (bb, _) in X) else 0) for b in data['berths']},
            'SB': SB,
            'SBJ': SBJ,
            'SQJ': SQJ,
            'G': G,
            'O': O,
            'Z': Z,
            'phi': phi,
            'gamma': gamma,
            'D': delay,
            'alpha': alpha_var,
            'beta': beta_var,
            'chi': chi_var,
            'psi': psi_var,
        }
        # 计算列的原始成本，便于输出
        F1_val = data['c_b'] * sum(phi.values()) + data['c_q'] * sum(gamma.values())
        F2_val = sum(data['c_j'] * max(0, G[j] - v_j[j]) for j in G)
        F3_val = data['c_s'] * sum(O.values())
        F4_val = data['c_d'] * delay
        column['objective'] = (
            data['alpha1'] * F1_val
            + data['alpha2'] * F2_val
            + data['alpha3'] * F3_val
            + data['alpha4'] * F4_val
        )
        column['F_components'] = (F1_val, F2_val, F3_val, F4_val)
        Hv[v].append(column)
        '''
        # 为了保证限制主问题在初始迭代即可行，再为每条船生成一个“虚拟列”。
        # 该列不占用任何泊位/岸桥资源，延迟取最大时间窗，赋予巨大惩罚成本，
        # 只在没有可行组合时才会被主问题选择，从而避免状态 3（不可行）。
        dummy_delay = data['t_l'] - data['t_s']
        dummy_Z = {('dummy', 'dummy'): 1}
        dummy_col = {
            'is_dummy': True,
            'X': {},
            'Y': {},
            'TS': {j: data['t_s'] for j in JR_v[v]},
            'TE': {j: data['t_s'] for j in JR_v[v]},
            'TE_v': data['t_s'],
            'S': {b: 0 for b in data['berths']},
            'E': {b: 0 for b in data['berths']},
            'SB': {},
            'SBJ': {},
            'SQJ': {},
            'G': {j: v_j[j] for j in JR_v[v]},
            'O': {},
            'Z': dummy_Z,
            'phi': {},
            'gamma': {},
            'D': dummy_delay,
            'alpha': {},
            'beta': {},
            'chi': {},
            'psi': {},
        }

        # 巨大惩罚确保算法优先选择真实列。
        dummy_F1 = 0
        dummy_F2 = 0
        dummy_F3 = data['c_s'] * (sum(dummy_Z.values()) - 1)
        dummy_F4 = data['c_d'] * dummy_delay * 100  # 加倍惩罚
        dummy_col['objective'] = (
            data['alpha1'] * dummy_F1
            + data['alpha2'] * dummy_F2
            + data['alpha3'] * dummy_F3
            + data['alpha4'] * dummy_F4
        )
        dummy_col['F_components'] = (dummy_F1, dummy_F2, dummy_F3, dummy_F4)

        Hv[v].append(dummy_col)
        '''
    return Hv


# =============================================================================
# 主问题 (2.4.1) 的限制主问题构建与求解
# =============================================================================

def build_master_model(data: Dict[str, Any], Hv: Dict[str, List[Dict]]):
    """构建限制主问题 (RMP)。"""
    model = gp.Model("DW_Master")
    model.Params.OutputFlag = 0

    s_vars = {}
    # 记录列的成本
    column_cost = {}

    # 为每条船的每个方案创建变量 s_hv（线性松弛）
    for v, cols in Hv.items():
        s_vars[v] = []
        for idx, col in enumerate(cols):
            var = model.addVar(lb=0.0, ub=1.0, vtype=GRB.CONTINUOUS, name=f"s_{v}_{idx}")
            s_vars[v].append(var)
            # 成本计算 (115) 中的四个分量
            F1 = data['c_b'] * sum(col['phi'].values()) + data['c_q'] * sum(col['gamma'].values())
            F2 = sum(data['c_j'] * max(0, col['G'][j] - data['v_j'][j]) for j in col['G'])
            # F3 = data['c_s'] * sum(col['O'].values())
            F3 = data['c_s'] * (sum(col['Z'].values())-1)
            F4 = data['c_d'] * col['D']
            obj_val = data['alpha1'] * F1 + data['alpha2'] * F2 + data['alpha3'] * F3 + data['alpha4'] * F4
            column_cost[(v, idx)] = obj_val

    model.update()

    # (116) 泊位占用约束：每个 b,t 只能服务一条船
    berth_constr = {}
    for b in data['berths']:
        for t in data['T_set']:
            expr = gp.LinExpr()
            for v, cols in Hv.items():
                for idx, col in enumerate(cols):
                    if col['SB'].get((b, t), 0) == 1:
                        expr += s_vars[v][idx]
            if expr.size() > 0:
                berth_constr[(b, t)] = model.addConstr(expr <= 1, name=f"berth_{b}_{t}")

    # (117) 岸桥占用约束：每个岸桥每个时刻最多一条船一个任务
    quay_constr = {}
    for q in data['Q']:
        for t in data['T_set']:
            expr = gp.LinExpr()
            for v, cols in Hv.items():
                for idx, col in enumerate(cols):
                    #for j in data['J_all']:
                    for j in data['JR_v'][v]:
                        if j in data['JQ']:  # 需要岸桥的任务
                            if col['SQJ'].get((q, j, t), 0) == 1:
                                expr += s_vars[v][idx]
                                break
            if expr.size() > 0:
                quay_constr[(q, t)] = model.addConstr(expr <= 1, name=f"quay_{q}_{t}")
    '''
    # (118) 每艘船选择一个方案
    vessel_constr = {}
    for v in Hv:
        constr = model.addConstr(gp.quicksum(s_vars[v]) == 1, name=f"assign_{v}")
        vessel_constr[v] = constr
    '''
    # 约束(118)：每艘船必须选择一个方案
    # ∑_{h_v∈H_v} s_{h_v} = 1, ∀v∈V
    vessel_constr = {}
    for v in data['V']:
        if v in s_vars and len(s_vars[v]) > 0:
            # 对船舶v的所有方案变量求和
            constr = model.addConstr(gp.quicksum(s_vars[v]) == 1, name=f"assign_{v}")
            vessel_constr[v] = constr
        else:
            # 如果s_vars中没有该船或方案列表为空，这是一个错误状态
            raise ValueError(f"船舶 {v} 没有有效的方案变量")


    # 目标函数 (115)
    obj_expr = gp.LinExpr()
    for (v, idx), cost in column_cost.items():
        obj_expr += cost * s_vars[v][idx]
    model.setObjective(obj_expr, GRB.MINIMIZE)

    model.update()
    #return model, s_vars, column_cost, vessel_constr, berth_constr, berth_task_constr, quay_constr
    return model, s_vars, column_cost, vessel_constr, berth_constr, quay_constr

# =============================================================================
# 子问题 (2.4.2) 求解：单船舶 Dantzig-Wolfe 子模型
# =============================================================================

def solve_subproblem(v: str, data: Dict[str, Any], duals: Dict[str, float]):
    """为单条船舶 v 构建并求解子问题。返回最优解与检验数。"""
    JR = data['JR_v'][v]
    B_j = data['B_j']
    JQ = data['JQ']
    JE = data['JE']
    p_jj_prime = data['p_jj_prime']
    Q = data['Q']
    tc_v = data['tc_v']
    v_j = data['v_j']
    vup_j = data['vup_j']
    M = data['M']
    t_ld = data['t_ld']
    t_s = data['t_s']
    T_set = data['T_set']
    n_vj = data['n_vj']
    x_base = data['x_vbj_baseline']
    y_base = data['y_vqj_baseline']
    t_v_d = data['t_v_d'][v]

    # 子问题模型
    m = gp.Model(f"Sub_{v}")
    m.Params.OutputFlag = 0

    # 变量定义 (120)~(160) 涵盖的所有变量
    X = m.addVars([(b, j) for j in JR for b in B_j[j]], vtype=GRB.BINARY, name="X")
    Y = m.addVars([(q, j) for j in JR if j in JQ for q in Q], vtype=GRB.BINARY, name="Y")
    TS = m.addVars(JR, lb=t_s, ub=data['t_l'], vtype=GRB.CONTINUOUS, name="TS")
    TE = m.addVars(JR, lb=t_s, ub=data['t_l'] + M, vtype=GRB.CONTINUOUS, name="TE")
    TE_v = m.addVar(lb=t_s, ub=data['t_l'] + M, vtype=GRB.CONTINUOUS, name="TE_v")
    S = m.addVars(data['berths'].keys(), lb=t_s, ub=data['t_l'] + M, vtype=GRB.CONTINUOUS, name="S")
    E = m.addVars(data['berths'].keys(), lb=t_s, ub=data['t_l'] + M, vtype=GRB.CONTINUOUS, name="E")
    SB = m.addVars([(b, t) for b in data['berths'] for t in T_set], vtype=GRB.BINARY, name="SB")
    SBJ = m.addVars([(b, j, t) for j in JR for b in B_j[j] for t in T_set], vtype=GRB.BINARY, name="SBJ")
    SQJ = m.addVars([(q, j, t) for j in JR if j in JQ for q in Q for t in T_set], vtype=GRB.BINARY, name="SQJ")
    G = m.addVars(JR, lb=0, ub=max(vup_j.values()), vtype=GRB.CONTINUOUS, name="G")
    O = m.addVars([(b1, b2) for b1 in data['berths'] for b2 in data['berths'] if b1 != b2], vtype=GRB.BINARY, name="O")
    Z = m.addVars(data['berths'].keys(), vtype=GRB.BINARY, name="Z")
    phi = m.addVars([(b, j) for j in JR for b in B_j[j]], vtype=GRB.BINARY, name="phi")
    gamma = m.addVars([(q, j) for j in JR if j in JQ for q in Q], vtype=GRB.BINARY, name="gamma")
    D = m.addVar(lb=0, ub=M, vtype=GRB.CONTINUOUS, name="D")
    alpha_var = m.addVars([(b, t) for b in data['berths'] for t in T_set], vtype=GRB.BINARY, name="alpha")
    beta_var = m.addVars([(b, t) for b in data['berths'] for t in T_set], vtype=GRB.BINARY, name="beta")
    chi_var = m.addVars([(q, j, t) for j in JR if j in JQ for q in Q for t in T_set], vtype=GRB.BINARY, name="chi")
    psi_var = m.addVars([(q, j, t) for j in JR if j in JQ for q in Q for t in T_set], vtype=GRB.BINARY, name="psi")

    # 约束 (121)~(160)：严格逐条给出
    # (121) 每个任务必须选择唯一泊位
    for j in JR:
        m.addConstr(gp.quicksum(X[b, j] for b in B_j[j]) == 1, name=f"c121_assign_berth_{j}")

    # (122) 需要岸桥的任务必须选择唯一岸桥
    for j in JR:
        if j in JQ:
            m.addConstr(gp.quicksum(Y[q, j] for q in Q) == 1, name=f"c122_assign_quay_{j}")

    '''
    # (123) 任务互斥约束
    for b in data['berths']:
        for j in JR:
            if j in JE:
                for j_prime in JR:
                    if j_prime != j and j_prime in JE:
                        m.addConstr(X[b, j] + X[b, j_prime] <= 1,
                                   name=f"c123_mutex_{b}_{j}_{j_prime}")
    '''
    '''
    #(123)修正后的任务互斥约束
    for b in data['berths']:
        for j in JR:
            for j_prime in JR:
                if j_prime != j and j_prime in JE:
                    m.addConstr(X[b, j] + X[b, j_prime] <= 1,
                            name=f"c123_mutex_{b}_{j}_{j_prime}")
    '''
    # (124) 任务优先级约束
    for j_prime in JR:
        for j in JR:
            if (j_prime, j) in p_jj_prime and p_jj_prime[(j_prime, j)] == 1:
                m.addConstr(TS[j] >= TE[j_prime] - M * (1 - p_jj_prime[(j_prime, j)]),
                           name=f"c124_precedence_{j_prime}_{j}")

    # (125) 任务执行时间约束
    for j in JR:
        m.addConstr(TE[j] == TS[j] + n_vj[(v, j)] / G[j],
                   name=f"c125_duration_{j}")

    # (126) 船舶结束时间约束
    for j in JR:
        m.addConstr(TE_v >= TE[j], name=f"c126_vessel_end_{j}")

    # (127) 船舶结束时间不超过截止时间
    m.addConstr(TE_v <= data['t_l'], name="c127_deadline")

    # (128) 任务开始时间不早于调度开始时间
    for j in JR:
        m.addConstr(TS[j] >= t_s, name=f"c128_start_time_{j}")

    # (129) 泊位最早开始时间约束
    for j in JR:
        for b in B_j[j]:
            m.addConstr(S[b] <= TS[j] + M * (1 - X[b, j]),
                       name=f"c129_berth_early_{b}_{j}")

    # (130) 泊位最晚结束时间约束
    for j in JR:
        for b in B_j[j]:
            m.addConstr(E[b] >= TE[j] - M * (1 - X[b, j]),
                       name=f"c130_berth_late_{b}_{j}")

    # (131)-(134) 泊位占用时间与时刻对应约束
    for b in data['berths']:
        for t in T_set:
            abs_time = t_s + t * t_ld
            # (131)
            m.addConstr(abs_time - S[b] >= -M * (1 - alpha_var[b, t]),
                       name=f"c131_alpha_lb_{b}_{t}")
            # (132)
            m.addConstr(abs_time - S[b] <= M * alpha_var[b, t] - 1e-5,
                       name=f"c132_alpha_ub_{b}_{t}")
            # (133)
            m.addConstr(E[b] - abs_time >= -M * (1 - beta_var[b, t]),
                       name=f"c133_beta_lb_{b}_{t}")
            # (134)
            m.addConstr(E[b] - abs_time <= M * beta_var[b, t] - 1e-5,
                       name=f"c134_beta_ub_{b}_{t}")
    '''
    # (135) SB变量关联约束
    for b in data['berths']:
        for t in T_set:
            m.addConstr(SB[b, t] >= alpha_var[b, t] + beta_var[b, t] + Z[b] - 2,
                       name=f"c135_SB_relation_{b}_{t}")
    '''

    # ========== 修改开始：SB变量关联约束 ==========
    # (135) SB变量关联约束 - 当 alpha_var + beta_var + Z - 2 = 1 时，SB = 1
    # 当 alpha_var + beta_var + Z - 2 = 1 时，即 alpha_var + beta_var + Z = 3
    for b in data['berths']:
        for t in T_set:
            # 约束1：当 alpha=1, beta=1, Z=1 时，SB必须为1
            m.addConstr(SB[b, t] >= alpha_var[b, t] + beta_var[b, t] + Z[b] - 2,
                        name=f"c135_SB_lower_bound_{b}_{t}")

            # 约束2：如果 alpha+beta+Z-2 < 1，则 SB 必须为 0
            # 当 alpha+beta+Z <= 2 时，alpha+beta+Z-2 <= 0，我们需要 SB <= 0
            # 我们可以通过三个约束来实现：
            # SB <= alpha (当alpha=0时，SB必须为0)
            # SB <= beta (当beta=0时，SB必须为0)
            # SB <= Z (当Z=0时，SB必须为0)
            m.addConstr(SB[b, t] <= alpha_var[b, t],
                        name=f"c135_SB_upper_alpha_{b}_{t}")
            m.addConstr(SB[b, t] <= beta_var[b, t],
                        name=f"c135_SB_upper_beta_{b}_{t}")
            m.addConstr(SB[b, t] <= Z[b],
                        name=f"c135_SB_upper_Z_{b}_{t}")
    # ========== 修改结束 ==========


    # (136) Z变量关联约束
    for b in data['berths']:
        for t in T_set:
            m.addConstr(Z[b] >= SB[b, t], name=f"c136_Z_relation_{b}_{t}")

    # (137)-(140) 岸桥任务执行时间与时刻对应约束
    for q in Q:
        for j in JR:
            if j in JQ:
                for t in T_set:
                    abs_time = t_s + t * t_ld
                    # (137)
                    m.addConstr(abs_time - TS[j] >= -M * (1 - chi_var[q, j, t]),
                               name=f"c137_chi_lb_{q}_{j}_{t}")
                    # (138)
                    m.addConstr(abs_time - TS[j] <= M * chi_var[q, j, t] - 1e-5,
                               name=f"c138_chi_ub_{q}_{j}_{t}")
                    # (139)
                    m.addConstr(TE[j] - abs_time >= -M * (1 - psi_var[q, j, t]),
                               name=f"c139_psi_lb_{q}_{j}_{t}")
                    # (140)
                    m.addConstr(TE[j] - abs_time <= M * psi_var[q, j, t] - 1e-5,
                               name=f"c140_psi_ub_{q}_{j}_{t}")
    '''
    # (141) SQJ变量关联约束
    for q in Q:
        for j in JR:
            if j in JQ:
                for t in T_set:
                    m.addConstr(SQJ[q, j, t] >= chi_var[q, j, t] + psi_var[q, j, t] + Y[q, j] - 2,
                               name=f"c141_SQJ_relation_{q}_{j}_{t}")
    '''
    # ========== 修改开始：SQJ变量关联约束 ==========
    # (141) SQJ变量关联约束 - 当 chi_var + psi_var + Y - 2 = 1 时，SQJ = 1
    # 当 chi_var + psi_var + Y - 2 = 1 时，即 chi_var + psi_var + Y = 3
    for q in Q:
        for j in JR:
            if j in JQ:
                for t in T_set:
                    # 约束1：当 chi=1, psi=1, Y=1 时，SQJ必须为1
                    m.addConstr(SQJ[q, j, t] >= chi_var[q, j, t] + psi_var[q, j, t] + Y[q, j] - 2,
                                name=f"c141_SQJ_lower_bound_{q}_{j}_{t}")

                    # 约束2：如果 chi+psi+Y-2 < 1，则 SQJ 必须为 0
                    # 当 chi+psi+Y <= 2 时，chi+psi+Y-2 <= 0，我们需要 SQJ <= 0
                    # 我们可以通过三个约束来实现：
                    # SQJ <= chi (当chi=0时，SQJ必须为0)
                    # SQJ <= psi (当psi=0时，SQJ必须为0)
                    # SQJ <= Y (当Y=0时，SQJ必须为0)
                    m.addConstr(SQJ[q, j, t] <= chi_var[q, j, t],
                                name=f"c141_SQJ_upper_chi_{q}_{j}_{t}")
                    m.addConstr(SQJ[q, j, t] <= psi_var[q, j, t],
                                name=f"c141_SQJ_upper_psi_{q}_{j}_{t}")
                    m.addConstr(SQJ[q, j, t] <= Y[q, j],
                                name=f"c141_SQJ_upper_Y_{q}_{j}_{t}")
    # ========== 修改结束 ==========

    # (142) Y变量关联约束
    for q in Q:
        for j in JR:
            if j in JQ:
                for t in T_set:
                    m.addConstr(Y[q, j] >= SQJ[q, j, t],
                               name=f"c142_Y_relation_{q}_{j}_{t}")

    # (143) SBJ与SB关联约束
    for b in data['berths']:
        for j in JR:
            if b in B_j[j]:
                for t in T_set:
                    m.addConstr(SBJ[b, j, t] <= SB[b, t],
                               name=f"c143_SBJ_relation_{b}_{j}_{t}")

    # (144)-(145) 移泊时间约束
    for b1 in data['berths']:
        for b2 in data['berths']:
            if b1 != b2:
                # (144)
                m.addConstr(E[b1] + tc_v <= S[b2] + M * (1 - O[b1, b2]),
                           name=f"c144_transfer_time1_{b1}_{b2}")
                # (145)
                m.addConstr(E[b2] + tc_v <= S[b1] + M * (1 - O[b2, b1]),
                           name=f"c145_transfer_time2_{b2}_{b1}")

    # (146) 移泊方向约束
    for b1 in data['berths']:
        for b2 in data['berths']:
            if b1 != b2:
                m.addConstr(O[b1, b2] + O[b2, b1] <= 1,
                           name=f"c146_transfer_dir_{b1}_{b2}")

    # (147) 移泊与泊位使用关联约束
    for b1 in data['berths']:
        for b2 in data['berths']:
            if b1 != b2:
                m.addConstr(O[b1, b2] + O[b2, b1] >= Z[b1] + Z[b2] - 1,
                           name=f"c147_transfer_Z_{b1}_{b2}")

    # (148)-(149) 移泊与泊位使用约束
    for b1 in data['berths']:
        for b2 in data['berths']:
            if b1 != b2:
                # (148)
                m.addConstr(O[b1, b2] <= Z[b1],
                           name=f"c148_O_Z1_{b1}_{b2}")
                # (149)
                m.addConstr(O[b1, b2] <= Z[b2],
                           name=f"c149_O_Z2_{b1}_{b2}")
                # (148.1)
                m.addConstr(O[b2, b1] <= Z[b1],
                           name=f"c148.1_O_Z1_{b2}_{b1}")
                # (149.1)
                m.addConstr(O[b2, b1] <= Z[b2],
                           name=f"c149.1_O_Z2_{b2}_{b1}")

    # (150) Z与X关联约束
    for b in data['berths']:
        for j in JR:
            if b in B_j[j]:
                m.addConstr(Z[b] >= X[b, j], name=f"c150_Z_X_{b}_{j}")

    # (151) X与Z关联约束（上限）
    for b in data['berths']:
        m.addConstr(gp.quicksum(X[b, j] for j in JR if b in B_j[j]) <= M * Z[b],
                   name=f"c151_X_Z_upper_{b}")

    # (152) X与Z关联约束（下限）
    for b in data['berths']:
        m.addConstr(gp.quicksum(X[b, j] for j in JR if b in B_j[j]) >= Z[b],
                   name=f"c152_X_Z_lower_{b}")

    # (153) 任务速率上限约束
    for j in JR:
        m.addConstr(G[j] <= vup_j[j], name=f"c153_rate_upper_{j}")

    # (154) 任务速率下限约束
    for j in JR:
        m.addConstr(G[j] >= v_j[j], name=f"c154_rate_lower_{j}")

    # (155)-(158) 线性化约束
    for j in JR:
        for b in B_j[j]:
            # (155)
            m.addConstr(phi[b, j] >= X[b, j] - (1 if (v, j) in x_base and x_base[(v, j)] == b else 0),
                       name=f"c155_phi_lb1_{b}_{j}")
            # (156)
            m.addConstr(phi[b, j] >= (1 if (v, j) in x_base and x_base[(v, j)] == b else 0) - X[b, j],
                       name=f"c156_phi_lb2_{b}_{j}")

    for j in JR:
        if j in JQ:
            for q in Q:
                # (157)
                m.addConstr(gamma[q, j] >= Y[q, j] - (1 if (v, j) in y_base and y_base[(v, j)] == q else 0),
                           name=f"c157_gamma_lb1_{q}_{j}")
                # (158)
                m.addConstr(gamma[q, j] >= (1 if (v, j) in y_base and y_base[(v, j)] == q else 0) - Y[q, j],
                           name=f"c158_gamma_lb2_{q}_{j}")

    # (159) 延迟计算约束
    m.addConstr(D >= TE_v - t_v_d, name="c159_delay")

    # (160) 变量取值范围约束已在变量定义时处理

    # 目标函数 (120)：加权成本 + 对偶值 * 资源使用 - η，形成检验数
    # 第一部分：原始成本项
    term1 = data['alpha1'] * data['c_b'] * gp.quicksum(phi[b, j] for j in JR for b in B_j[j])
    term2 = data['alpha1'] * data['c_q'] * gp.quicksum(gamma[q, j] for j in JR if j in JQ for q in Q)
    term3 = data['alpha2'] * gp.quicksum(data['c_j'] * (G[j] - v_j[j]) for j in JR)
    term4 = data['alpha3'] * data['c_s'] * (gp.quicksum(Z[b] for b in data['berths']) - 1)
    term5 = data['alpha4'] * data['c_d'] * D

    original_cost = term1 + term2 + term3 + term4 + term5

    # 第二部分：对偶值项（资源使用成本）
    dual_cost = gp.LinExpr()

    # SB'_{vbt} * σ_{bt} 项
    for b in data['berths']:
        for t in T_set:
            dual_var_name = f"berth_{b}_{t}"
            if dual_var_name in duals:
                dual_cost += duals[dual_var_name] * SB[b, t]

    # SQJ'_{vqjt} * τ_{qt} 项
    for q in Q:
        for t in T_set:
            dual_var_name = f"quay_{q}_{t}"
            if dual_var_name in duals:
                # 对每个需要岸桥的任务j
                for j in JR:
                    if j in JQ:
                        dual_cost += duals[dual_var_name] * SQJ[q, j, t]

    # 第三部分：减去 η_v (船舶方案选择约束的对偶变量)
    eta_v = duals.get(f"assign_{v}", 0)

    # 完整的目标函数：原始成本 - 资源使用成本 - η_v
    total_objective = original_cost - dual_cost - eta_v

    m.setObjective(total_objective, GRB.MINIMIZE)
    m.update()

    m.optimize()

    # 检查子问题状态
    if m.status != GRB.OPTIMAL:
        print(f"子问题 {v} 求解状态: {m.status}")
        if m.status == GRB.INFEASIBLE:
            print(f"警告: 船舶 {v} 的子问题不可行，可能约束过于严格")
            m.computeIIS()
            m.write(f"subproblem_{v}_infeasible.ilp")
            print(f"已生成船舶 {v} 的不可行性报告")
        elif m.status == GRB.UNBOUNDED:
            print(f"警告: 船舶 {v} 的子问题无界")
        else:
            print(f"警告: 船舶 {v} 的子问题未能达到最优状态")

        # 返回None表示没有找到可行列
        return None, float('inf')  # 使用很大的正值确保不会被选为新列

    reduced_cost = m.ObjVal

    # 提取解形成列
    col = {
        'X': {(b, j): int(round(X[b, j].X)) for b, j in X.keys() if X[b, j].X > 0.5},
        'Y': {(q, j): int(round(Y[q, j].X)) for q, j in Y.keys() if Y[q, j].X > 0.5},
        'TS': {j: TS[j].X for j in JR},
        'TE': {j: TE[j].X for j in JR},
        'TE_v': TE_v.X,
        'S': {b: S[b].X for b in data['berths']},
        'E': {b: E[b].X for b in data['berths']},
        'SB': {(b, t): int(round(SB[b, t].X)) for b, t in SB.keys() if SB[b, t].X > 0.5},
        'SBJ': {(b, j, t): int(round(SBJ[b, j, t].X)) for b, j, t in SBJ.keys() if SBJ[b, j, t].X > 0.5},
        'SQJ': {(q, j, t): int(round(SQJ[q, j, t].X)) for q, j, t in SQJ.keys() if SQJ[q, j, t].X > 0.5},
        'G': {j: G[j].X for j in JR},
        'O': {(b1, b2): int(round(O[b1, b2].X)) for b1, b2 in O.keys() if O[b1, b2].X > 0.5},
        'Z': {b: int(round(Z[b].X)) for b in data['berths'] if Z[b].X > 0.5},
        'phi': {(b, j): int(round(phi[b, j].X)) for b, j in phi.keys() if phi[b, j].X > 0.5},
        'gamma': {(q, j): int(round(gamma[q, j].X)) for q, j in gamma.keys() if gamma[q, j].X > 0.5},
        'D': D.X,
        'alpha': {(b, t): int(round(alpha_var[b, t].X)) for b, t in alpha_var.keys() if alpha_var[b, t].X > 0.5},
        'beta': {(b, t): int(round(beta_var[b, t].X)) for b, t in beta_var.keys() if beta_var[b, t].X > 0.5},
        'chi': {(q, j, t): int(round(chi_var[q, j, t].X)) for q, j, t in chi_var.keys() if chi_var[q, j, t].X > 0.5},
        'psi': {(q, j, t): int(round(psi_var[q, j, t].X)) for q, j, t in psi_var.keys() if psi_var[q, j, t].X > 0.5},
    }

    # 计算真实成本用于主问题
    F1_val = data['c_b'] * sum(col['phi'].values()) + data['c_q'] * sum(col['gamma'].values())
    F2_val = sum(data['c_j'] * max(0, col['G'][j] - v_j[j]) for j in col['G'])
    #F3_val = data['c_s'] * sum(col['O'].values())
    F3_val = data['c_s'] * (sum(col['Z'].values()) - 1)  # 修正：使用泊位数量减1
    F4_val = data['c_d'] * col['D']
    col['objective'] = data['alpha1'] * F1_val + data['alpha2'] * F2_val + data['alpha3'] * F3_val + data['alpha4'] * F4_val

    return col, reduced_cost


# =============================================================================
# 列生成主流程
# =============================================================================

def column_generation(data: Dict[str, Any]):
    """完整的列生成循环，返回最终 Hv 与主问题模型。"""
    Hv = generate_initial_columns(data)

    # 初始列输出，便于对照启发式效果
    print_initial_columns(Hv, data, title="初始列生成启发式结果")

    # 迭代：每轮先构建/求解 RMP，再用对偶值求解子问题，若有改进则重建 RMP
    iteration = 0
    max_iterations = 50  # 防止无限循环
    while iteration < max_iterations:
        iteration += 1
        print(f"\n======== 列生成迭代 {iteration} ========")
        model, s_vars, column_cost, vessel_constr, berth_constr, quay_constr = build_master_model(data, Hv)
        model.optimize()

        # 检查模型是否成功优化
        if model.status != GRB.OPTIMAL:
            print(f"主问题求解失败，状态: {model.status}")
            if model.status == GRB.INFEASIBLE:
                print("模型不可行。检查约束是否过于严格。")
                # 尝试输出不可行性报告
                model.computeIIS()
                model.write("infeasible.ilp")
                print("已生成不可行性报告: infeasible.ilp")
            elif model.status == GRB.UNBOUNDED:
                print("模型无界。检查目标函数和约束。")
            else:
                print(f"未知状态: {model.status}")
            break

        print(f"主问题目标值: {model.ObjVal:.2f}")

        # 获取对偶值
        duals = {}
        for v_name, c in vessel_constr.items():
            duals[c.ConstrName] = c.Pi
        for (b, t), c in berth_constr.items():
            duals[c.ConstrName] = c.Pi
        for (q, t), c in quay_constr.items():
            duals[c.ConstrName] = c.Pi

        improving = False
        new_columns = defaultdict(list)

        # 求解每艘船的子问题
        for v in data['V']:
            col, rc = solve_subproblem(v, data, duals)
            if col is not None and rc < -1e-6:  # 允许一定容差
                print(f"船舶 {v} 找到改进列，检验数: {rc:.4f}")
                new_columns[v].append(col)
                improving = True

        # 若无改进列则停止
        if not improving:
            print("未找到改进列，列生成算法收敛")
            break

        # 将新列加入 Hv 后重新构建下一轮 RMP
        for v, cols in new_columns.items():
            Hv[v].extend(cols)
            print(f"为船舶 {v} 添加了 {len(cols)} 个新列")

    if iteration >= max_iterations:
        print("达到最大迭代次数，列生成算法提前终止")

    # 最终再解一次确保获得最终解
    final_model, final_s_vars, final_column_cost, _, _, _ = build_master_model(data, Hv)
    final_model.optimize()

    # 检查最终模型状态
    if final_model.status != GRB.OPTIMAL:
        print(f"最终主问题求解失败，状态: {final_model.status}")
        if final_model.status == GRB.INFEASIBLE:
            final_model.computeIIS()
            final_model.write("final_infeasible.ilp")
            print("已生成最终不可行性报告: final_infeasible.ilp")

    return final_model, Hv, final_s_vars, final_column_cost


# =============================================================================
# 结果打印
# =============================================================================

def print_initial_columns(Hv, data, title: str = "初始列"):
    """按最终格式打印启发式生成的初始列（每船首列）。"""
    print("==================================================")
    print(title)
    print("==================================================")

    # 由于初始列每艘船仅一条方案，直接取 index=0
    total_obj = sum(col.get('objective', 0) for v_cols in Hv.values() for col in v_cols)
    print(f"目标函数值: {total_obj:.2f}")
    print("求解时间: 0.00 秒 (启发式生成)\n")

    F1 = F2 = F3 = F4 = 0
    for v, cols in Hv.items():
        col = cols[0]
        f1, f2, f3, f4 = col.get('F_components', (0, 0, 0, 0))
        F1 += f1
        F2 += f2
        F3 += f3
        F4 += f4
    weighted = data['alpha1'] * F1 + data['alpha2'] * F2 + data['alpha3'] * F3 + data['alpha4'] * F4
    print("各目标分量值:")
    print(f"F1 (资源偏离惩罚): {F1:.2f}")
    print(f"F2 (速率提升成本): {F2:.2f}")
    print(f"F3 (移泊惩罚成本): {F3:.2f}")
    print(f"F4 (延迟惩罚成本): {F4:.2f}")
    print(f"验证加权目标值: {weighted:.2f}\n")

    print("船舶调度方案:\n")
    for v in data['V']:
        col = Hv[v][0]
        print(f"船舶 {v}:")
        print(f"  完成时间: {col['TE_v']:.2f}, 预期离港: {data['t_v_d'][v]}, 延迟: {col['D']:.2f}")
        for j in data['JR_v'][v]:
            ts = col['TS'][j]
            te = col['TE'][j]
            rate = col['G'][j]
            berth = next((b for (b, jj) in col['X'] if jj == j), 'N/A')
            base_b = data['x_vbj_baseline'].get((v, j), '无')
            tag_b = "符合" if base_b == berth else "偏离"
            print(f"  任务 {j}: 开始={ts:.2f}, 结束={te:.2f}, 速率={rate:.2f}")
            print(f"    泊位: {berth} (基线: {base_b}) [{tag_b}]")
            if j in data['JQ']:
                quay = next((q2 for (q2, jj) in col['Y'] if jj == j), 'N/A')
                base_q = data['y_vqj_baseline'].get((v, j), '无')
                tag_q = "符合" if base_q == quay else "偏离"
                print(f"    岸桥: {quay} (基线: {base_q}) [{tag_q}]")
        print()

    print("移泊情况:")
    for v in data['V']:
        col = Hv[v][0]
        for (b1, b2), val in col['O'].items():
            if val > 0.5:
                print(f"  船舶 {v}: 从泊位 {b1} 移泊到 {b2}")
    print()

    # 泊位视角
    print("==================================================")
    print("泊位视角任务执行情况")
    print("==================================================\n")
    for b in data['berths']:
        print(f"泊位 {b}:")
        print("  船舶       任务       开始时间       结束时间       持续时间      ")
        print("  -------- -------- ---------- ---------- ----------")
        for v in data['V']:
            col = Hv[v][0]
            for j in data['JR_v'][v]:
                if any(bb == b and jj == j for (bb, jj) in col['X'].keys()):
                    ts = col['TS'][j]
                    te = col['TE'][j]
                    print(f"  {v:<8} {j:<8} {ts:<10.2f} {te:<10.2f} {te - ts:<10.2f}")
        print()

    # 岸桥视角
    print("==================================================")
    print("岸桥视角任务执行情况")
    print("==================================================\n")
    for q in data['Q']:
        print(f"岸桥 {q}:")
        print("  船舶       任务       泊位       开始时间       结束时间       持续时间      ")
        print("  -------- -------- -------- ---------- ---------- ----------")
        for v in data['V']:
            col = Hv[v][0]
            for j in data['JR_v'][v]:
                if j in data['JQ']:
                    q_selected = next((qq for (qq, jj) in col['Y'] if jj == j and qq == q), None)
                    b_selected = next((bb for (bb, jj) in col['X'] if jj == j), None)
                    if q_selected:
                        ts = col['TS'][j]
                        te = col['TE'][j]
                        print(f"  {v:<8} {j:<8} {b_selected:<8} {ts:<10.2f} {te:<10.2f} {te - ts:<10.2f}")
        print()

def print_solution(model, data, Hv, s_vars, column_cost):
    """按照需求格式打印最终解。"""
    if model.Status != GRB.OPTIMAL:
        print(f"模型状态为 {model.Status}，无法输出可行解。")
        return

    # 总目标值
    total_obj = model.ObjVal
    print(f"目标函数值: {total_obj:.2f}")
    print(f"求解时间: {model.Runtime:.2f} 秒\n")

    # 计算目标分量
    F1 = F2 = F3 = F4 = 0
    chosen_cols = {}
    for v, vars_list in s_vars.items():
        for idx, var in enumerate(vars_list):
            if var.X > 1e-6:
                chosen_cols[v] = (idx, var.X)
                col = Hv[v][idx]
                F1 += data['c_b'] * sum(col['phi'].values()) + data['c_q'] * sum(col['gamma'].values())
                F2 += sum(data['c_j'] * max(0, col['G'][j] - data['v_j'][j]) for j in col['G'])
                #F3 += data['c_s'] * sum(col['O'].values())
                F3 += data['c_s'] * (sum(col['Z'].values()) - 1)
                F4 += data['c_d'] * col['D']

    weighted = data['alpha1'] * F1 + data['alpha2'] * F2 + data['alpha3'] * F3 + data['alpha4'] * F4
    print("各目标分量值:")
    print(f"F1 (资源偏离惩罚): {F1:.2f}")
    print(f"F2 (速率提升成本): {F2:.2f}")
    print(f"F3 (移泊惩罚成本): {F3:.2f}")
    print(f"F4 (延迟惩罚成本): {F4:.2f}")
    print(f"验证加权目标值: {weighted:.2f}\n")

    print("船舶调度方案:\n")
    for v in data['V']:
        idx, val = chosen_cols.get(v, (0, 0))
        col = Hv[v][idx]
        print(f"船舶 {v}:")
        print(f"  完成时间: {col['TE_v']:.2f}, 预期离港: {data['t_v_d'][v]}, 延迟: {col['D']:.2f}")
        for j in data['JR_v'][v]:
            ts = col['TS'][j]
            te = col['TE'][j]
            rate = col['G'][j]
            berth = next((b for (b, jj) in col['X'] if jj == j), 'N/A')
            base_b = data['x_vbj_baseline'].get((v, j), '无')
            tag_b = "符合" if base_b == berth else "偏离"
            print(f"  任务 {j}: 开始={ts:.2f}, 结束={te:.2f}, 速率={rate:.2f}")
            print(f"    泊位: {berth} (基线: {base_b}) [{tag_b}]")
            if j in data['JQ']:
                quay = next((q2 for (q2, jj) in col['Y'] if jj == j), 'N/A')
                base_q = data['y_vqj_baseline'].get((v, j), '无')
                tag_q = "符合" if base_q == quay else "偏离"
                print(f"    岸桥: {quay} (基线: {base_q}) [{tag_q}]")
        print()

    # 移泊情况
    print("移泊情况:")
    for v in data['V']:
        idx, _ = chosen_cols.get(v, (0, 0))
        col = Hv[v][idx]
        for (b1, b2), val in col['O'].items():
            if val > 0.5:
                print(f"  船舶 {v}: 从泊位 {b1} 移泊到 {b2}")
    print()

    # 泊位视角
    print("==================================================")
    print("泊位视角任务执行情况")
    print("==================================================\n")
    for b in data['berths']:
        print(f"泊位 {b}:")
        print("  船舶       任务       开始时间       结束时间       持续时间      ")
        print("  -------- -------- ---------- ---------- ----------")
        for v in data['V']:
            idx, _ = chosen_cols.get(v, (0, 0))
            col = Hv[v][idx]
            for j in data['JR_v'][v]:
                if any(bb == b and jj == j for (bb, jj) in col['X'].keys()):
                    ts = col['TS'][j]
                    te = col['TE'][j]
                    print(f"  {v:<8} {j:<8} {ts:<10.2f} {te:<10.2f} {te - ts:<10.2f}")
        print()

    # 岸桥视角
    print("==================================================")
    print("岸桥视角任务执行情况")
    print("==================================================\n")
    for q in data['Q']:
        print(f"岸桥 {q}:")
        print("  船舶       任务       泊位       开始时间       结束时间       持续时间      ")
        print("  -------- -------- -------- ---------- ---------- ----------")
        for v in data['V']:
            idx, _ = chosen_cols.get(v, (0, 0))
            col = Hv[v][idx]
            for j in data['JR_v'][v]:
                if j in data['JQ']:
                    q_selected = next((qq for (qq, jj) in col['Y'] if jj == j and qq == q), None)
                    b_selected = next((bb for (bb, jj) in col['X'] if jj == j), None)
                    if q_selected:
                        ts = col['TS'][j]
                        te = col['TE'][j]
                        print(f"  {v:<8} {j:<8} {b_selected:<8} {ts:<10.2f} {te:<10.2f} {te - ts:<10.2f}")
        print()


# =============================================================================
# 主入口
# =============================================================================

if __name__ == "__main__":
    data = load_data()
    model, Hv, s_vars, column_cost = column_generation(data)
    print_solution(model, data, Hv, s_vars, column_cost)