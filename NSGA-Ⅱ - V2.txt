"""
基于DMIPM-Ⅰ模型的多目标NSGA-II示例，并在版本 1 上加入 TSSMIPM-Ⅰ 的随机场景抽样平均近似（SAA）。

本文件包含：
1. 详细的算法步骤说明（中文）。
2. 可直接运行的Demo，读取`Data_TwoWeek.xlsx`生成船舶任务数据并执行NSGA-II。
3. 伪代码示例，方便快速浏览算法逻辑。

伪代码概览：
    输入：船舶任务数据、泊位配置、任务速率、岸桥数量、移泊时间、大M
    输出：帕累托解集（决策变量取值 + 对应多目标值）

    # SAA 扩展：
    #   在 evaluate_schedule 中重复采样 arrival/TC_V/VJ（正态分布，均值为基准值，标准差分别为 4/5/6），
    #   对每个场景排程求得目标，最后取均值作为 TSSMIPM-Ⅰ 近似目标。

    初始化种群：
        - 为每条船的每个任务随机选择可行泊位与岸桥
    循环迭代（代数 G）
        - 计算每个个体的任务排程，得到四个目标值
        - 非支配排序，计算拥挤度
        - 选择操作（拥挤锦标赛）
        - 交叉操作（在任务基因上均匀交叉）
        - 变异操作（随机更换泊位/岸桥）
        - 生成下一代
    返回第一前沿中的若干代表性解
"""
from __future__ import annotations

import argparse
import math
import random
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional, Any

from xml.etree import ElementTree as ET
from zipfile import ZipFile


# --------------------------- 数据结构定义 --------------------------- #

@dataclass
class TaskGene:
    """单个任务的决策基因表示。

    Attributes:
        task: 任务类型，例如 j1~j7
        workload: 任务作业量（从 Excel 读取，对应处理吨数/方数等）
        berth_choice: 在 Bj[task] 中的索引，指示所选泊位
        quay_choice: 若任务需要岸桥，则为 Q 中的索引；否则为 None
    """

    task: str
    workload: float
    berth_choice: int
    quay_choice: Optional[int] = None


@dataclass
class ShipChromosome:
    """单条船舶的完整染色体信息。

    berth 字段用于确保“每艘船舶最多停靠一个泊位”，所有任务均在此泊位上执行。
    """

    vessel: str
    arrival: float
    departure: float
    genes: List[TaskGene]
    berth: Optional[str] = None


@dataclass
class Individual:
    """整体解（所有船舶的染色体集合）。"""

    ships: List[ShipChromosome]
    objectives: Tuple[float, float, float, float] = field(default_factory=lambda: (math.inf,) * 4)
    constraint_violation: float = 0.0
    rank: int = 0
    crowding_distance: float = 0.0
    # 在评估阶段写入：{vessel: [(task, berth, quay, start, end), ...]}
    schedule: Dict[str, List[Tuple[str, str, Optional[str], float, float]]] = field(default_factory=dict)


# --------------------------- 模型常量与辅助集 --------------------------- #

# 泊位属性配置
BERTHS: Dict[str, List[str]] = {
    "b1": ["j1"],
    "b2": ["j2", "j3", "j4"],
    "b3": ["j2", "j3", "j5", "j6", "j7"],
    "b4": ["j2", "j3", "j4", "j5", "j6", "j7"],
}

# Bj：能执行任务 j 的泊位集合
BJ: Dict[str, List[str]] = {j: [] for j in ["j1", "j2", "j3", "j4", "j5", "j6", "j7"]}
for berth, jobs in BERTHS.items():
    for job in jobs:
        BJ[job].append(berth)

# 岸桥集合
Q = ["q1", "q2", "q3"]

# 需要岸桥作业的任务集合
JQ = ["j2", "j3"]

# 与其他任务互斥的任务集合（在同一泊位上不能并行）
JE = ["j1"]

# p_jj' 参数，仅 (2,3) 取 1，其他为 0，用于目标4 的相邻任务偏好
P_MATRIX = {("j2", "j3"): 1}

# 任务执行速率（单位：单位工作量/小时）
VJ = {
    "j1": 100,
    "j2": 20,
    "j3": 20,
    "j4": 70,
    "j5": 45,
    "j6": 150,
    "j7": 100,
}

# 其他参数（基础均值）
TC_V = 0.5  # 移泊时间（小时）
M_BIG = 1e4

# ------------- 不确定性设置（TSSMIPM-Ⅰ，使用 SAA） ------------- #

# arrival、TC_V、VJ 的正态分布标准差
ARRIVAL_STD = 4.0
TC_V_STD = 5.0
VJ_STD = 6.0

# SAA 场景数，可在 CLI 通过 --saa 调整
SAA_SAMPLES = 20


# --------------------------- 数据读取与初始化 --------------------------- #

def _read_xlsx_rows(path: str) -> List[Dict[str, Any]]:
    """轻量级 XLSX 解析函数，避免依赖外部库。

    仅解析第一个工作表，默认第一行为表头。
    """

    def column_index(col: str) -> int:
        idx = 0
        for ch in col:
            idx = idx * 26 + (ord(ch.upper()) - ord("A") + 1)
        return idx - 1

    with ZipFile(path) as zf:
        shared_strings: List[str] = []
        if "xl/sharedStrings.xml" in zf.namelist():
            ss_root = ET.fromstring(zf.read("xl/sharedStrings.xml"))
            for si in ss_root.findall(".//{http://schemas.openxmlformats.org/spreadsheetml/2006/main}t"):
                shared_strings.append(si.text or "")

        sheet_xml = zf.read("xl/worksheets/sheet1.xml")
        root = ET.fromstring(sheet_xml)
        ns = {"a": "http://schemas.openxmlformats.org/spreadsheetml/2006/main"}
        rows_raw: List[List[Any]] = []
        for row in root.findall("a:sheetData/a:row", ns):
            values: Dict[int, Any] = {}
            for cell in row.findall("a:c", ns):
                ref = cell.attrib.get("r", "A1")
                col_letters = "".join(ch for ch in ref if ch.isalpha())
                idx = column_index(col_letters)
                cell_type = cell.attrib.get("t")
                v_node = cell.find("a:v", ns)
                if v_node is None:
                    continue
                raw_val = v_node.text or ""
                if cell_type == "s":
                    val = shared_strings[int(raw_val)] if raw_val.isdigit() else raw_val
                else:
                    try:
                        val = float(raw_val)
                    except ValueError:
                        val = raw_val
                values[idx] = val
            if values:
                rows_raw.append(values)

    if not rows_raw:
        return []

    # 第一行作为表头
    header_row = rows_raw[0]
    headers = [header_row.get(i, f"col{i}") for i in range(max(header_row.keys()) + 1)]
    data_rows: List[Dict[str, Any]] = []
    for row_values in rows_raw[1:]:
        row_dict: Dict[str, Any] = {}
        for idx, name in enumerate(headers):
            row_dict[name] = row_values.get(idx, 0)
        data_rows.append(row_dict)
    return data_rows


def _apply_ship_berth(ship: ShipChromosome) -> bool:
    """校正每个任务的泊位索引，确保落在对应 Bj 集合中。

    原始版本强制整船使用单一泊位，导致当任务的 Bj 交集为空时产生必然的 M_BIG 违约，
    进而所有个体的约束违约度都被同量级惩罚，非支配关系退化为单点。
    这里改为逐任务修正泊位索引，允许不同任务在可行泊位间切换，同时仍然满足
    约束 (31)~(58) 对任务泊位可行性的要求。
    """

    feasible = True
    ship.berth = None
    for gene in ship.genes:
        if gene.task not in JQ:
            gene.quay_choice = None
        berth_list = BJ.get(gene.task, [])
        if not berth_list:
            feasible = False
            continue
        gene.berth_choice %= len(berth_list)
    return feasible


def load_ships_from_excel(path: str) -> List[ShipChromosome]:
    """从 Excel 读取船舶与任务信息。

    约定列名：
        - Vessel No.
        - Expected arrival time
        - Expected departure time
        - Unloading / Loading / Refueling / Charging / Water-filling / Adding ash / Adding mud
    """

    rows = _read_xlsx_rows(path)
    ships: List[ShipChromosome] = []
    for row in rows:
        tasks = []
        mapping = {
            "Refueling": "j1",
            "Unloading": "j2",
            "Loading": "j3",
            "Charging": "j4",
            "Water-filling": "j5",
            "Adding ash": "j6",
            "Adding mud": "j7",
        }
        for col, task in mapping.items():
            qty = float(row.get(col, 0) or 0)
            if qty > 0:
                berth_choice = random.randrange(len(BJ[task]))
                quay_choice: Optional[int] = None
                if task in JQ:
                    quay_choice = random.randrange(len(Q))
                tasks.append(
                    TaskGene(
                        task=task,
                        workload=qty,
                        berth_choice=berth_choice,
                        quay_choice=quay_choice,
                    )
                )
        if not tasks:
            continue
        ship = ShipChromosome(
            vessel=str(row["Vessel No."]),
            arrival=float(row["Expected arrival time"]),
            departure=float(row["Expected departure time"]),
            genes=tasks,
        )
        _apply_ship_berth(ship)
        ships.append(ship)
    return ships


# --------------------------- 调度与目标计算 --------------------------- #

def _find_feasible_start(
        earliest: float,
        duration: float,
        intervals: List[Tuple[float, float, str]],
        vessel: str,
        allow_same_vessel_parallel: bool = False,
) -> float:
    """在给定资源区间中，为指定船舶找到不与其他船重叠的最早开始时间。

    allow_same_vessel_parallel 为 True 时，同一船舶在同一资源上的并行占用被允许，
    仅阻止与其他船舶的重叠，用于满足“同船可在同泊位同时作业（除互斥约束外）”的要求。
    """

    start = earliest
    while True:
        conflict_found = False
        for s, e, v in intervals:
            if allow_same_vessel_parallel and v == vessel:
                continue
            if not (start + duration <= s or start >= e):
                start = e
                conflict_found = True
                break
        if not conflict_found:
            return start


def _sample_uncertain_params(ships: List[ShipChromosome]) -> Tuple[Dict[str, float], float, Dict[str, float]]:
    """基于正态分布采样一个场景的 arrival/TC_V/VJ，并对采样值进行截断以避免极端异常。"""

    arrival_sample: Dict[str, float] = {}
    for ship in ships:
        arrival_sample[ship.vessel] = max(0.0, random.gauss(ship.arrival, ARRIVAL_STD))

    tc_v_raw = 0.0
    # 拒绝采样确保满足 "移泊时间服从正态分布且 >= 0.01"，避免长期被 0.01 截断
    while tc_v_raw < 0.01:
        tc_v_raw = random.gauss(TC_V, TC_V_STD)
    tc_v_sample = min(tc_v_raw, TC_V * 3)

    vj_sample: Dict[str, float] = {}
    for task, rate in VJ.items():
        sampled = random.gauss(rate, VJ_STD)
        vj_sample[task] = min(max(rate * 0.5, sampled), rate * 1.5)

    return arrival_sample, tc_v_sample, vj_sample


def _evaluate_single(
        individual: Individual,
        arrival_override: Dict[str, float],
        tc_v: float,
        vj_sample: Dict[str, float],
        record_schedule: bool = False,
) -> Tuple[Tuple[float, float, float, float], float, Dict[str, List[Tuple[str, str, Optional[str], float, float]]]]:
    """在单个随机场景下排程，返回目标值、违约度和（可选）调度表。"""

    berth_intervals: Dict[str, List[Tuple[float, float, str]]] = {b: [] for b in BERTHS}
    quay_intervals: Dict[str, List[Tuple[float, float, str]]] = {q: [] for q in Q}

    total_delay_time = 0.0
    total_reberth = 0.0
    gap_list: List[float] = []
    all_intervals: List[Tuple[float, float, str, str]] = []
    violation = 0.0

    schedule: Dict[str, List[Tuple[str, str, Optional[str], float, float]]] = {}

    for ship in individual.ships:
        berth_feasible = _apply_ship_berth(ship)
        if not berth_feasible:
            violation += M_BIG

        arrival_time = arrival_override.get(ship.vessel, ship.arrival)

        first_start: Optional[float] = None
        last_berth: Optional[str] = None
        last_berth_end = arrival_time
        latest_end = arrival_time
        j2_end: Optional[float] = None

        vessel_block_until = arrival_time

        ship_intervals: List[Tuple[str, float, float]] = []  # (task, start, end)

        schedule[ship.vessel] = [None] * len(ship.genes)

        non_j3_tasks = [
            (idx, g) for idx, g in enumerate(ship.genes) if g.task != "j3"
        ]
        j3_tasks = [(idx, g) for idx, g in enumerate(ship.genes) if g.task == "j3"]
        has_j2_task = any(g.task == "j2" for g in ship.genes)

        berth_segment_start: Optional[float] = None

        def _enforce_j1_exclusivity(start_candidate: float, duration: float, task: str) -> float:
            """确保 j1 与同船其他任务互斥，其他任务仅需避让 j1。"""
            start = start_candidate
            while True:
                conflict = False
                for t_name, s_val, e_val in ship_intervals:
                    if task == "j1" or t_name == "j1":
                        if not (start + duration <= s_val or start >= e_val):
                            start = e_val
                            conflict = True
                            break
                if not conflict:
                    return start

        for idx, gene in non_j3_tasks + j3_tasks:
            berth_list = BJ.get(gene.task, [])
            if not berth_list:
                violation += M_BIG
                continue
            berth_idx = gene.berth_choice % len(berth_list)
            berth = berth_list[berth_idx]

            quay = None
            if gene.task in JQ:
                if gene.quay_choice is None:
                    violation += M_BIG
                else:
                    quay = Q[gene.quay_choice % len(Q)]
            else:
                gene.quay_choice = None

            workload = gene.workload if gene.workload > 0 else 1.0
            duration = workload / vj_sample[gene.task]

            earliest_start = max(ship.arrival, arrival_time, vessel_block_until)
            if gene.task == "j3" and has_j2_task:
                if j2_end is not None:
                    earliest_start = max(earliest_start, j2_end)
                else:
                    violation += M_BIG

            if last_berth is not None and berth != last_berth:
                earliest_start = max(earliest_start, last_berth_end + tc_v)
                total_reberth += 1

            if berth_segment_start is None or berth != last_berth:
                berth_segment_start = earliest_start

            # 泊位独占：阻止与其他船舶的任何重叠，同船泊位可并行（另由 j1 / j2→j3 管理）
            berth_blocks = berth_intervals[berth]
            earliest_start = _find_feasible_start(
                earliest_start,
                duration,
                berth_blocks,
                ship.vessel,
                allow_same_vessel_parallel=True,
            )

            if quay is not None:
                quay_blocks = quay_intervals[quay]
                earliest_start = _find_feasible_start(
                    earliest_start,
                    duration,
                    quay_blocks,
                    ship.vessel,
                    allow_same_vessel_parallel=True,
                )
            earliest_start = _enforce_j1_exclusivity(earliest_start, duration, gene.task)

            start_time = earliest_start
            end_time = start_time + duration

            berth_intervals[berth].append((start_time, end_time, ship.vessel))
            all_intervals.append((start_time, end_time, berth, ship.vessel))
            if quay is not None:
                quay_intervals[quay].append((start_time, end_time, ship.vessel))

            if gene.task in JE:
                vessel_block_until = end_time
            last_berth = berth
            last_berth_end = max(last_berth_end, end_time)
            latest_end = max(latest_end, end_time)
            if gene.task == "j2":
                j2_end = end_time
            ship_intervals.append((gene.task, start_time, end_time))

            if first_start is None:
                first_start = start_time
            schedule[ship.vessel][idx] = (gene.task, berth, quay, start_time, end_time)

        completion = latest_end
        delay = max(0.0, completion - ship.departure)
        total_delay_time += delay

    for berth, intervals in berth_intervals.items():
        if len(intervals) <= 1:
            continue
        sorted_intervals = sorted(intervals, key=lambda x: x[0])
        for (s1, e1, v1), (s2, e2, v2) in zip(sorted_intervals, sorted_intervals[1:]):
            if s2 < e1 and v1 != v2:
                # 任何跨船泊位重叠视为硬约束违约
                violation += M_BIG
            elif s2 > e1:
                gap_list.append(s2 - e1)

    if len(all_intervals) > 1:
        sorted_all = sorted(all_intervals, key=lambda x: x[0])
        for (s1, e1, b1, _), (s2, e2, b2, _) in zip(sorted_all, sorted_all[1:]):
            if b1 != b2 and s2 > e1:
                gap_list.append(s2 - e1)

    avg_gap = sum(gap_list) / len(gap_list) if gap_list else 0.0

    entropy = 0.0
    if gap_list:
        total_gap = sum(gap_list)
        for g in gap_list:
            p = g / total_gap
            entropy += -p * math.log(p)

    objectives = (total_delay_time, total_reberth, -avg_gap, -entropy)
    return objectives, violation, schedule if record_schedule else {}


def evaluate_schedule(
        individual: Individual,
        verbose: bool = False,
        saa_samples: int = SAA_SAMPLES,
        deterministic: bool = False,
) -> None:
    """基于 SAA 评估 TSSMIPM-Ⅰ：对多个随机场景求平均目标/违约度。

    deterministic=True 时，使用基准参数（原始到港、TC_V、VJ）单场景评估，
    使打印的帕累托解与展示的调度表一致，避免多场景均值导致的感知误差。
    """

    obj_acc = [0.0, 0.0, 0.0, 0.0]
    vio_acc = 0.0
    kept_schedule: Dict[str, List[Tuple[str, str, Optional[str], float, float]]] = {}

    sample_total = 1 if deterministic else max(1, saa_samples)
    for idx in range(sample_total):
        if deterministic:
            arrival_s = {ship.vessel: ship.arrival for ship in individual.ships}
            tc_v_s = TC_V
            vj_s = VJ
        else:
            arrival_s, tc_v_s, vj_s = _sample_uncertain_params(individual.ships)

        objectives, violation, schedule = _evaluate_single(
            individual,
            arrival_override=arrival_s,
            tc_v=tc_v_s,
            vj_sample=vj_s,
            record_schedule=idx == 0,
        )
        for i in range(4):
            obj_acc[i] += objectives[i]
        vio_acc += violation
        if idx == 0:
            kept_schedule = schedule

    individual.objectives = tuple(val / sample_total for val in obj_acc)
    individual.constraint_violation = vio_acc / sample_total
    individual.schedule = kept_schedule

    if verbose:
        print("目标值:", individual.objectives, "违约:", individual.constraint_violation)


# --------------------------- NSGA-II 核心操作 --------------------------- #

def dominates(ind_a: Individual, ind_b: Individual) -> bool:
    """判断 A 是否支配 B（考虑约束）。"""
    if ind_a.constraint_violation != ind_b.constraint_violation:
        return ind_a.constraint_violation < ind_b.constraint_violation
    better_or_equal = all(a <= b for a, b in zip(ind_a.objectives, ind_b.objectives))
    strictly_better = any(a < b for a, b in zip(ind_a.objectives, ind_b.objectives))
    return better_or_equal and strictly_better


def non_dominated_sort(population: List[Individual]) -> List[List[Individual]]:
    """快速非支配排序。"""
    fronts: List[List[Individual]] = []
    dominated_by_count = {id(ind): 0 for ind in population}
    dominates_list: Dict[int, List[Individual]] = {id(ind): [] for ind in population}

    for p in population:
        for q in population:
            if p is q:
                continue
            if dominates(p, q):
                dominates_list[id(p)].append(q)
            elif dominates(q, p):
                dominated_by_count[id(p)] += 1
        if dominated_by_count[id(p)] == 0:
            p.rank = 1

    first_front = [p for p in population if dominated_by_count[id(p)] == 0]
    fronts.append(first_front)

    i = 0
    while fronts[i]:
        next_front: List[Individual] = []
        for p in fronts[i]:
            for q in dominates_list[id(p)]:
                dominated_by_count[id(q)] -= 1
                if dominated_by_count[id(q)] == 0:
                    q.rank = i + 2
                    next_front.append(q)
        i += 1
        fronts.append(next_front)
    fronts.pop()  # 移除最后一个空层
    return fronts


def crowding_distance(front: List[Individual]) -> None:
    """计算某一前沿的拥挤度。"""
    if not front:
        return
    num_objectives = len(front[0].objectives)
    for ind in front:
        ind.crowding_distance = 0.0
    for m in range(num_objectives):
        front.sort(key=lambda x: x.objectives[m])
        front[0].crowding_distance = front[-1].crowding_distance = math.inf
        min_val = front[0].objectives[m]
        max_val = front[-1].objectives[m]
        if math.isclose(max_val, min_val):
            continue
        for i in range(1, len(front) - 1):
            prev_val = front[i - 1].objectives[m]
            next_val = front[i + 1].objectives[m]
            front[i].crowding_distance += (next_val - prev_val) / (max_val - min_val)


def tournament_selection(population: List[Individual], k: int = 2) -> Individual:
    """基于支配层级与拥挤度的锦标赛选择。"""
    contestants = random.sample(population, k)
    contestants.sort(key=lambda ind: (ind.rank, -ind.crowding_distance))
    return contestants[0]


def crossover(parent1: Individual, parent2: Individual, prob: float = 0.9) -> Tuple[Individual, Individual]:
    """均匀交叉：同一船舶下的任务泊位/岸桥独立交换。"""
    if random.random() > prob:
        return parent1, parent2
    child1_ships: List[ShipChromosome] = []
    child2_ships: List[ShipChromosome] = []
    for ship1, ship2 in zip(parent1.ships, parent2.ships):
        genes1: List[TaskGene] = []
        genes2: List[TaskGene] = []
        for g1, g2 in zip(ship1.genes, ship2.genes):
            if random.random() < 0.5:
                src1, src2 = g1, g2
            else:
                src1, src2 = g2, g1
            genes1.append(
                TaskGene(
                    task=src1.task,
                    workload=src1.workload,
                    berth_choice=src1.berth_choice,
                    quay_choice=src1.quay_choice,
                )
            )
            genes2.append(
                TaskGene(
                    task=src2.task,
                    workload=src2.workload,
                    berth_choice=src2.berth_choice,
                    quay_choice=src2.quay_choice,
                )
            )
        child1 = ShipChromosome(ship1.vessel, ship1.arrival, ship1.departure, genes1, ship1.berth)
        child2 = ShipChromosome(ship2.vessel, ship2.arrival, ship2.departure, genes2, ship2.berth)
        _apply_ship_berth(child1)
        _apply_ship_berth(child2)
        child1_ships.append(child1)
        child2_ships.append(child2)
    return Individual(child1_ships), Individual(child2_ships)


def mutate(individual: Individual, prob: float = 0.1) -> None:
    """随机变异：重新选择统一泊位或岸桥。"""
    for ship in individual.ships:
        if random.random() < prob:
            # 船级泊位变异：重新挑选单一泊位
            _apply_ship_berth(ship)
        for gene in ship.genes:
            if gene.task in JQ and random.random() < prob:
                gene.quay_choice = random.randrange(len(Q))


# --------------------------- 主流程 --------------------------- #

def make_initial_population(ships_proto: List[ShipChromosome], size: int) -> List[Individual]:
    population: List[Individual] = []
    for _ in range(size):
        ships_clone: List[ShipChromosome] = []
        for ship in ships_proto:
            genes = []
            for gene in ship.genes:
                berth_choice = random.randrange(len(BJ[gene.task]))
                quay_choice = gene.quay_choice
                if gene.task in JQ:
                    quay_choice = random.randrange(len(Q))
                genes.append(TaskGene(gene.task, gene.workload, berth_choice, quay_choice))
            clone = ShipChromosome(ship.vessel, ship.arrival, ship.departure, genes)
            _apply_ship_berth(clone)
            ships_clone.append(clone)
        indiv = Individual(ships_clone)
        evaluate_schedule(indiv)
        population.append(indiv)
    return population


def nsga2(ships_proto: List[ShipChromosome], pop_size: int = 100, generations: int = 300) -> List[Individual]:
    population = make_initial_population(ships_proto, pop_size)

    for i in range(generations):
        print (i)
        # 非支配排序 + 拥挤度
        fronts = non_dominated_sort(population)
        for front in fronts:
            crowding_distance(front)

        # 生成子代
        offspring: List[Individual] = []
        while len(offspring) < pop_size:
            p1 = tournament_selection(population)
            p2 = tournament_selection(population)
            c1, c2 = crossover(p1, p2)
            mutate(c1)
            mutate(c2)
            evaluate_schedule(c1)
            evaluate_schedule(c2)
            offspring.extend([c1, c2])

        # 合并并截断
        combined = population + offspring
        fronts = non_dominated_sort(combined)
        new_population: List[Individual] = []
        for front in fronts:
            crowding_distance(front)
            if len(new_population) + len(front) <= pop_size:
                new_population.extend(front)
            else:
                front.sort(key=lambda ind: ind.crowding_distance, reverse=True)
                needed = pop_size - len(new_population)
                new_population.extend(front[:needed])
                break
        population = new_population

    # 最终前沿
    final_fronts = non_dominated_sort(population)
    best_front = final_fronts[0]
    for front in final_fronts:
        crowding_distance(front)
    return best_front


def print_solutions(front: List[Individual]) -> None:
    """打印帕累托前沿解的决策变量和目标值。"""
    if not front:
        print("无帕累托解。")
        return

    # 为了让展示的调度与目标完全一致，这里用确定性参数重新评估一次
    for ind in front:
        evaluate_schedule(ind, saa_samples=1, deterministic=True)

    print(f"帕累托解数量: {len(front)}")

    objectives_matrix = list(zip(*(ind.objectives for ind in front)))
    objective_names = [
        "延迟时间",
        "移泊次数",
        "-平均间隙",
        "-结构熵",
    ]

    for idx, (name, values) in enumerate(zip(objective_names, objectives_matrix), 1):
        max_val = max(values)
        min_val = min(values)
        mean_val = sum(values) / len(values)
        print(
            f"目标{idx}（{name}）统计：最大值 = {max_val:.4f}, "
            f"均值 = {mean_val:.4f}, 最小值 = {min_val:.4f}"
        )

    for idx, ind in enumerate(front, 1):
        print(f"\n解 {idx}：")
        for ship in ind.ships:
            print(f"  船舶 {ship.vessel} (到港 {ship.arrival}, 离港 {ship.departure})")
            schedule_rows = ind.schedule.get(ship.vessel, [])
            for gene, sched in zip(ship.genes, schedule_rows if schedule_rows else [None] * len(ship.genes)):
                berth = BJ[gene.task][gene.berth_choice % len(BJ[gene.task])]
                quay = Q[gene.quay_choice % len(Q)] if (gene.task in JQ and gene.quay_choice is not None) else "-"
                if sched is None:
                    print(f"    任务 {gene.task} -> 泊位 {berth}, 岸桥 {quay}")
                else:
                    _, berth_used, quay_used, start_t, end_t = sched
                    quay_label = quay_used if quay_used is not None else "-"
                    print(
                        f"    任务 {gene.task} -> 泊位 {berth_used}, 岸桥 {quay_label}, "
                        f"开始 {start_t:.2f}, 结束 {end_t:.2f}"
                    )
        print(f"  帕累托目标值 (延迟时间, 移泊次数, -平均间隙, -结构熵) = {ind.objectives}")
        print(f"  约束违约度 = {ind.constraint_violation}")


# --------------------------- CLI --------------------------- #

def main() -> None:
    global SAA_SAMPLES
    parser = argparse.ArgumentParser(description="基于 DMIPM-Ⅰ 的 NSGA-II Demo")
    parser.add_argument("--excel", default="D:\Data_Day1.xlsx", help="包含船舶任务信息的 Excel 路径")
    parser.add_argument("--pop", type=int, default=100, help="种群规模")
    parser.add_argument("--gen", type=int, default=100, help="进化代数")
    parser.add_argument("--saa", type=int, default=SAA_SAMPLES, help="SAA 场景数量")
    args = parser.parse_args()

    ships_proto = load_ships_from_excel(args.excel)
    if not ships_proto:
        raise SystemExit("未读取到任何船舶任务，请检查数据文件。")

    SAA_SAMPLES = max(1, args.saa)

    best_front = nsga2(ships_proto, pop_size=args.pop, generations=args.gen)
    print_solutions(best_front)


if __name__ == "__main__":
    main()